function Vertex(inbound, outbound) {
    this.in = inbound || [];
    this.out = outbound || [];
    this.visited = false;
}

function addEdge(nodes, vertTail, vertHead) {
    if (!nodes.hasOwnProperty(vertTail)) {
        nodes[vertTail] = new Vertex(); // create vertex
    }
    nodes[vertTail].out.push(vertHead);//add pointer to another node
    if (!nodes.hasOwnProperty(vertHead)) {
        nodes[vertHead] = new Vertex();//create vertex to point to
    }
    nodes[vertHead].in.push(vertTail);// store a node pointing here
}

function nodesToEdgesArr(nodes) {
    const verts = Object.keys(nodes);
    const edges = [];
    for (var i = 0; i < verts.length; i++) {
        var vertLabel = parseInt(verts[i]);
        var outgoing = nodes[vertLabel].out;
        //taking only outgoing:
        for (var j = 0; j < outgoing.length; j++) {
            var outLabel = outgoing[j];
            edges.push([vertLabel, outLabel])
        }
    }
    return edges;
}

function reverseEdges(nodes) {
    const edges = nodesToEdgesArr(nodes);
    const nodesWithReversedEdges = {};
    for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        // add edge reversed into new graph
        addEdge(nodesWithReversedEdges, edge[1], edge[0]);
    }
    return nodesWithReversedEdges;
}

function DFS(nodes, vertexLabel, leaderLabel, reverseEdges, onNewNodeExplored) {
    const currentVertex = nodes[vertexLabel];
    if (currentVertex.visited) {
        return;
    }
    currentVertex.visited = true;
    currentVertex.leader = leaderLabel;

    const neighbors = reverseEdges ? currentVertex.in : currentVertex.out;
    for (var i = 0; i < neighbors.length; i++) {
        var neighborLabel = neighbors[i];
        var neighbor = nodes[neighborLabel];
        if (neighbor.visited !== true) {
            DFS(nodes, neighborLabel, leaderLabel, reverseEdges, onNewNodeExplored);
        }
    }
    onNewNodeExplored(vertexLabel);
}
function findFinishingTimes(Graph) {
    const finishingTimes = {};
    const labels = Object.keys(Graph).sort().reverse();
    var t = 0;
    var s = null;
    const onNewNodeExplored = function onNewNodeExplored(vertexLabel) {
        t++;
        finishingTimes[vertexLabel] = t;
    };
 
    for (var i = 0; i < labels.length; i++) {
        var labelIth = labels[i];
        var currentVertex = Graph[labelIth];
        if (currentVertex.visited === false) {
            s = labelIth;
            DFS(Graph, labelIth, s, true, onNewNodeExplored);
            //finishingTimes[labelIth] = t;
        }
    }
    return finishingTimes;
}
function findLeaders(Graph, finishingTimes) {
    const leaders = {};

    return leaders;
}

function findSCCs(Graph) {
    //Kosaraju's two pass:
    // 1) run Depth-first search (aka DFS) on the reversed graph, to compute ordering of nodes
    // by finding "finishing time" for nodes
    const finishingTimes = findFinishingTimes(Graph);

    // 3) run DFS on original graph, finding Strongly Connected Components (SCCs)
    const leaders = findLeaders(Graph, finishingTimes);
    // return leaders object, containing information about vertices with the same leaderId
    return leaders;
}

module.exports = {
    Vertex: Vertex,
    findSCCs: findSCCs,
    addEdge: addEdge,
    nodesToEdgesArr: nodesToEdgesArr,
    reverseEdges: reverseEdges,
    findFinishingTimes: findFinishingTimes,
    DFS: DFS
};